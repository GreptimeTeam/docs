# RANGE QUERY

查询并聚合一个给定长度的时间范围的数据是时序数据常见的一种查询模式，例如 `PromQL` 中的 `Range selector`。而 GreptimeDB 在 SQL 中支持了 Range 查询，用于将时序数据汇总为时间块，并在时间块上进行数据的聚合。Range 查询作为 `SELECT` 语句的一部分，可与 SQL 灵活结合，从而在 SQL 中提供更强大的时序数据查询能力。

## Syntax

一个合法的 Range 查询语法结构如下所示：

```sql
SELECT
  AGGR_FUNCTION(column1, column2,..) RANGE INTERVAL [FILL FILL_OPTION],
  ...
FROM table_name
ALIGN INTERVAL [ TO TO_OPTION ] [BY (columna, columnb,..)] [FILL FILL_OPTION];

INTERVAL :=  TIME_INTERVAL | ( INTERVAL expr ) 
```

- 关键字 `ALIGN`，必选字段，后接参数 `INTERVAL` ，`ALIGN` 指明了 Range 查询的步长。
  - 子关键字 `TO` ，可选字段，指定 Range 查询对齐到的时间点，合法的 `TO_OPTION` 参数见[TO Option](#to-option) 。
  - 子关键字 `BY` ，可选字段，后接参数 `(columna, columnb,..)` ，描述了聚合键。若该字段未给出，默认使用表的主键作为聚合键。
- 参数 `INTERVAL` ，主要用于给出一段时间长度，有两种参数形式：
  - 基于 `PromQL Time Durations` 格式的字符串（例如：`3h`、`1h30m`）。访问 [Prometheus 文档](https://prometheus.io/docs/prometheus/latest/querying/basics/#time-durations) 获取该格式更详细的说明。
  - `Interval` 类型，使用 `Interval` 类型需要携带括号,（例如：`(INTERVAL '1 year 3 hours 20 minutes')`）。访问 [Interval](./functions.md#interval) 获取该格式更详细的说明。
- `AGGR_FUNCTION(column1, column2,..) RANGE INTERVAL [FILL FILL_OPTION]` 称为一个 Range 表达式。
  - `AGGR_FUNCTION(column1, column2,..)` 是一个聚合函数，代表需要聚合的表达式
  - 关键字 `RANGE`，必选字段，后接参数 `INTERVAL` 指定了每次数据聚合的时间范围，
  - 关键字 `FILL`，可选字段，后接参数 `FILL_OPTION` 指明了聚合字段为空时的数据填充方法。
  - Range 表达式可与其他运算结合，实现更复杂的查询。具体见[嵌套使用 Range 表达式](#嵌套使用-range-表达式) 。
- 关键字 `FILL`，可以跟在一个 Range 表达式后，作为这个 Range 表达式的数据填充方法；也可以放在 `ALIGN` 后作为缺省数据填充方法。合法的 `FILL_OPTION` 参数见[FILL Option](#fill-option) 。

## 示例

下面这张 `host_cpu` 表，记录了两台机器 `host1` 和 `host2` 在某个时间消耗的 CPU ，以该表为例介绍如何进行 Range 查询。

```sql
+---------------------+-------+------+
| ts                  | host  | cpu  |
+---------------------+-------+------+
| 1970-01-01 08:00:00 | host1 |  1.1 |
| 1970-01-01 08:00:05 | host1 |  2.2 |
| 1970-01-01 08:00:00 | host2 |  3.3 |
| 1970-01-01 08:00:05 | host2 |  4.4 |
+---------------------+-------+------+
```

使用下面的 SQL 语句创建数据表：

```sql
CREATE TABLE host_cpu (
  ts timestamp(3) time index,
  host STRING PRIMARY KEY,
  cpu Float64,
);

INSERT INTO TABLE host_cpu VALUES
    (0,     'host1', 1.1),
    (5000,  'host1', 2.2),
    (0,     'host2', 3.3),
    (5000,  'host2', 4.4);
```

运行这句 Range 查询：

```sql
SELECT 
    ts, 
    host, 
    min(cpu) RANGE '10s',
    max(cpu) RANGE '10s' FILL LINEAR 
FROM host_cpu 
ALIGN '5s' BY (host) FILL PREV;
```

运行后可以得到查询结果：

```sql
+---------------------+-------+---------------------------------------+-----------------------------------------+
| ts                  | host  | MIN(host_cpu.cpu) RANGE 10s FILL PREV | MAX(host_cpu.cpu) RANGE 10s FILL LINEAR |
+---------------------+-------+---------------------------------------+-----------------------------------------+
| 1970-01-01 08:00:00 | host2 |                                   3.3 |                                     3.3 |
| 1970-01-01 08:00:05 | host2 |                                   3.3 |                                     4.4 |
| 1970-01-01 08:00:10 | host2 |                                   4.4 |                                     4.4 |
| 1970-01-01 08:00:00 | host1 |                                   1.1 |                                     1.1 |
| 1970-01-01 08:00:05 | host1 |                                   1.1 |                                     2.2 |
| 1970-01-01 08:00:10 | host1 |                                   2.2 |                                     2.2 |
+---------------------+-------+---------------------------------------+-----------------------------------------+
```


上面这个 RANGE  查询，每隔 5s 统计了一次某台机器在 10s 以内使用 CPU 的最小值和最大值：
1. `ALIGN '5s'` 指明按照  5s 为步长，进行数据的统计，步长对齐到日历。
2. `BY (host)` 指明了聚合键，`BY` 关键字支持省略。如果省略 `BY` 关键字，则默认使用数据表的主键作为聚合键。
3. `max(cpu) RANGE '10s' FILL LINEAR` 是一个 Range 表达式。`RANGE '10s'` 指明了聚合的时间跨度为 10s，`FILL LINEAR` 指明了如果在某个聚合的时间内没有数据的话，使用 `LINEAR` 方式填充。
4. `FILL` 关键字可以跟在 `RANGE` 关键字后面，表示这个 Range 表达式的填充方式，`FILL` 关键字也可以跟在 `BY` 关键字后，作为没有给出 `FILL` 关键字的 Range 表达式的缺省值。`min(cpu) RANGE '10s'` 这个 Range 表达式没有给出 `FILL` ，所以采用缺省的 FILL 填充方式，即 `PREV`。如果缺省的 FILL 也没有给出，则采用 `NULL` 方式填充。


想要使用 Range 查询，该数据表上必须有一列数据在建表时声明为 `time index`，Range 查询使用该列数据作为聚合的时间线依据，如果该数据表没有指定主键，则关键字 `BY` 不能省略。用户也可以使用 `BY` 关键字，声明其他列作为数据聚合的依据。比如下面这个 RANGE 查询，使用 `host` 列的字符串长度 `length(host)` 作为数据聚合的依据。

```sql
SELECT 
    ts, 
    length(host), 
    min(cpu) RANGE '10s' 
FROM host_cpu ALIGN '5s' BY (length(host));
```

运行后可以得到结果：

```sql
+---------------------+---------------------------------+---------------------------------------+
| ts                  | character_length(host_cpu.host) | MIN(host_cpu.cpu) RANGE 10s FILL NULL |
+---------------------+---------------------------------+---------------------------------------+
| 1970-01-01 08:00:00 |                               5 |                                   1.1 |
| 1970-01-01 08:00:05 |                               5 |                                   1.1 |
| 1970-01-01 08:00:10 |                               5 |                                   2.2 |
+---------------------+---------------------------------+---------------------------------------+
```

用户也可以显式通过 `BY ()` 声明**不需要使用聚合键**，将所有数据全部聚合到一个 group 里。**但用户如果直接将 `BY` 关键字省略，则代表着使用数据表的主键来作为数据的聚合键。**

```sql
SELECT 
    ts, 
    min(cpu) RANGE '10s' 
FROM host_cpu ALIGN '5s' BY ();
```

运行后可以得到结果：

```sql
+---------------------+---------------------------------------+
| ts                  | MIN(host_cpu.cpu) RANGE 10s FILL NULL |
+---------------------+---------------------------------------+
| 1970-01-01 08:00:05 |                                   1.1 |
| 1970-01-01 08:00:00 |                                   1.1 |
| 1970-01-01 08:00:10 |                                   2.2 |
+---------------------+---------------------------------------+
```

## FILL OPTION

FILL 有以下几种填充方式：

|   FILL   |                                                      描述                                                      |
| :------: | :------------------------------------------------------------------------------------------------------------: |
|  `NULL`  |                                        直接使用 `NULL` 填充（默认方式）                                        |
|  `PREV`  |                                             使用前一个点的数据填充                                             |
| `LINEAR` | 使用[线性插值](https://wiki.mbalib.com/wiki/线性插值法)填充数据，如果一个整数类型使用 `LINEAR` 填充，则该列的变量类型会在计算的时候被隐式转换为浮点类型 |
|   `X`    |                        填充一个常量，该常量的数据类型必须和 Range 表达式的变量类型一致                         |


以下面这张表为例

```sql
+---------------------+-------+------+
| ts                  | host  | cpu  |
+---------------------+-------+------+
| 1970-01-01 08:00:00 | host1 |  4.5 |
| 1970-01-01 08:00:05 | host1 | NULL |
| 1970-01-01 08:00:10 | host1 |  6.5 |
+---------------------+-------+------+
```

使用 `NULL` 进行 FILL

```sql
SELECT ts, min(cpu) RANGE '5s' FILL NULL FROM host_cpu ALIGN '5s';
```

运行后得到结果：

```sql
+---------------------+--------------------------------------+
| ts                  | MIN(host_cpu.cpu) RANGE 5s FILL NULL |
+---------------------+--------------------------------------+
| 1970-01-01 08:00:00 |                                  4.5 |
| 1970-01-01 08:00:05 |                                 NULL |
| 1970-01-01 08:00:10 |                                  6.5 |
+---------------------+--------------------------------------+
```

使用 `PREV` 进行 FILL

```sql
SELECT ts, min(cpu) RANGE '5s' FILL PREV FROM host_cpu ALIGN '5s';
```

运行后得到结果：

```sql
+---------------------+--------------------------------------+
| ts                  | MIN(host_cpu.cpu) RANGE 5s FILL PREV |
+---------------------+--------------------------------------+
| 1970-01-01 08:00:00 |                                  4.5 |
| 1970-01-01 08:00:05 |                                  4.5 |
| 1970-01-01 08:00:10 |                                  6.5 |
+---------------------+--------------------------------------+
```

使用 `LINEAR` 进行 FILL

```sql
SELECT ts, min(cpu) RANGE '5s' FILL LINEAR FROM host_cpu ALIGN '5s';
```

运行后得到结果：

```sql
+---------------------+----------------------------------------+
| ts                  | MIN(host_cpu.cpu) RANGE 5s FILL LINEAR |
+---------------------+----------------------------------------+
| 1970-01-01 08:00:00 |                                    4.5 |
| 1970-01-01 08:00:05 |                                    5.5 |
| 1970-01-01 08:00:10 |                                    6.5 |
+---------------------+----------------------------------------+
```

使用常量值 `6.0` 进行 FILL

```sql
SELECT ts, min(cpu) RANGE '5s' FILL 6.0 FROM host_cpu ALIGN '5s';
```

运行后得到结果：

```sql
+---------------------+-----------------------------------+
| ts                  | MIN(host_cpu.cpu) RANGE 5s FILL 6 |
+---------------------+-----------------------------------+
| 1970-01-01 08:00:00 |                               4.5 |
| 1970-01-01 08:00:05 |                                 6 |
| 1970-01-01 08:00:10 |                               6.5 |
+---------------------+-----------------------------------+
```

## TO OPTION

关键字 `TO` ，指定 Range 查询对齐到的时间点，合法的 `TO` 选项有：

|     TO      |                                描述                                |
| :---------: | :----------------------------------------------------------------: |
| `CALENDAR`  |                 对齐到 UTC 时间 0 时刻（默认方式）                 |
|    `NOW`    |                         对齐到当前查询时间                         |
| `Timestamp` | 对齐到一个用户指定的时间戳上，支持时间戳格式 `RFC3339` / `ISO8601` |

使用下面的例子说明 `TO` 关键字的用法，首先执行下面的 SQL 语句创建数据表：

```sql
CREATE TABLE host (
  ts timestamp(3) time index,
  host STRING PRIMARY KEY,
  val BIGINT,
);

INSERT INTO TABLE host VALUES
    ("1970-01-01T02:00:00+08:00", 'host1', 0),
    ("1970-01-01T10:00:00+08:00", 'host1', 1),
    ("1970-01-01T02:00:00+08:00", 'host2', 2),
    ("1970-01-01T10:00:00+08:00", 'host2', 3);
```

用户不指定 `TO` 关键字，默认使用 `CALENDAR` 方式，将时间对齐到 UTC 时间 0 时刻。

```sql
SELECT ts, host, min(val) RANGE (INTERVAL '1' day) FROM host ALIGN (INTERVAL '1' day);
```

运行后得到结果：

```sql
+---------------------+-------+----------------------------------------------------------------------------+
| ts                  | host  | MIN(host.val) RANGE IntervalMonthDayNano("18446744073709551616") FILL NULL |
+---------------------+-------+----------------------------------------------------------------------------+
| 1970-01-01 08:00:00 | host1 |                                                                          0 |
| 1970-01-02 08:00:00 | host1 |                                                                          1 |
| 1970-01-01 08:00:00 | host2 |                                                                          2 |
| 1970-01-02 08:00:00 | host2 |                                                                          3 |
+---------------------+-------+----------------------------------------------------------------------------+
```

如果用户想查询在北京时间下每天 `val` 的最小值，需要使用 `TO` 关键字，将查询时间对齐到东八区时间，运行下面的 Range 查询：

```sql
SELECT ts, host, min(val) RANGE (INTERVAL '1' day) FROM host ALIGN (INTERVAL '1' day) TO '1900-01-01T00:00:00+08:00';
```

运行后得到结果：

```sql
+---------------------+-------+----------------------------------------------------------------------------+
| ts                  | host  | MIN(host.val) RANGE IntervalMonthDayNano("18446744073709551616") FILL NULL |
+---------------------+-------+----------------------------------------------------------------------------+
| 1970-01-02 00:00:00 | host1 |                                                                          0 |
| 1970-01-02 00:00:00 | host2 |                                                                          2 |
+---------------------+-------+----------------------------------------------------------------------------+
```

通过手动指定对齐时间，我们可以指定查询时区，也可以查询特定时间范围的数据。比如使用下面这条语句，我们可以查询从北京时间 `00:45` - `02:45` 这个时间段内的每日 `val` 最小值：

```sql
SELECT ts, host, min(val) RANGE '2h' FROM host ALIGN '1d' TO '1900-01-01T02:45:00+08:00';
```

用户可以阅读 [Range 查询原理](#range-查询原理)，了解 Range 查询聚合时间段的计算方法，从而更好的理解上述查询的原理。

运行后得到结果：

```sql
+---------------------+-------+----------------------------------+
| ts                  | host  | MIN(host.val) RANGE 2h FILL NULL |
+---------------------+-------+----------------------------------+
| 1970-01-01 02:45:00 | host1 |                                0 |
| 1970-01-01 02:45:00 | host2 |                                2 |
+---------------------+-------+----------------------------------+
```

用户也可以通过指定 `NOW`，将对齐时间设置为查询时间，假设现在的查询时间为 `2023-12-01T16:29:58.470000+8:00`.运行下面的语句:

```sql
SELECT ts, host, min(val) RANGE '1d' FROM host ALIGN '1d' TO NOW;
```

可以得到查询结果

```sql
+----------------------------+-------+----------------------------------+
| ts                         | host  | MIN(host.val) RANGE 1d FILL NULL |
+----------------------------+-------+----------------------------------+
| 1970-01-01 16:29:58.470000 | host1 |                                0 |
| 1970-01-01 16:29:58.470000 | host2 |                                2 |
+----------------------------+-------+----------------------------------+
```

## 嵌套使用 Range 表达式

Range 表达式支持灵活的嵌套，可以将 Range 表达式结合各种运算，提供更强大的查询能力。

以下面这张表为例：

```sql
+---------------------+-------+------+
| ts                  | host  | cpu  |
+---------------------+-------+------+
| 1970-01-01 08:00:00 | host1 |  1.1 |
| 1970-01-01 08:00:05 | host1 |  2.2 |
| 1970-01-01 08:00:00 | host2 |  3.3 |
| 1970-01-01 08:00:05 | host2 |  4.4 |
+---------------------+-------+------+
```

1. 聚合函数内部和外部都支持计算：

```sql
SELECT ts, host, 2.0 * min(cpu * 2.0) RANGE '10s' FROM host_cpu ALIGN '5s';
```

运行后得到

```sql
+---------------------+-------+-----------------------------------------------------------------+
| ts                  | host  | Float64(2) * MIN(host_cpu.cpu * Float64(2)) RANGE 10s FILL NULL |
+---------------------+-------+-----------------------------------------------------------------+
| 1970-01-01 08:00:00 | host2 |                                                            13.2 |
| 1970-01-01 08:00:10 | host2 |                                                            17.6 |
| 1970-01-01 08:00:05 | host2 |                                                            13.2 |
| 1970-01-01 08:00:10 | host1 |                                                             8.8 |
| 1970-01-01 08:00:05 | host1 |                                                             4.4 |
| 1970-01-01 08:00:00 | host1 |                                                             4.4 |
+---------------------+-------+-----------------------------------------------------------------+
```


2. 聚合函数内部和外部都支持使用 Scalar 函数：
   - `min(round(cpu)) RANGE '10s'` 表示对每个值先使用 `round` 函数四舍五入后再进行聚合
   - `round(min(cpu) RANGE '10s')` 表示对每个聚合完成的结果使用 `round` 函数四舍五入

```sql
SELECT ts, host, min(round(cpu)) RANGE '10s' FROM host_cpu ALIGN '5s';
```
运行后得到

```sql
+---------------------+-------+----------------------------------------------+
| ts                  | host  | MIN(round(host_cpu.cpu)) RANGE 10s FILL NULL |
+---------------------+-------+----------------------------------------------+
| 1970-01-01 08:00:05 | host1 |                                            1 |
| 1970-01-01 08:00:00 | host1 |                                            1 |
| 1970-01-01 08:00:10 | host1 |                                            2 |
| 1970-01-01 08:00:00 | host2 |                                            3 |
| 1970-01-01 08:00:10 | host2 |                                            4 |
| 1970-01-01 08:00:05 | host2 |                                            3 |
+---------------------+-------+----------------------------------------------+
```


```sql
SELECT ts, host, round(min(cpu) RANGE '10s') FROM host_cpu ALIGN '5s';
```

运行后得到

```sql
+---------------------+-------+----------------------------------------------+
| ts                  | host  | round(MIN(host_cpu.cpu) RANGE 10s FILL NULL) |
+---------------------+-------+----------------------------------------------+
| 1970-01-01 08:00:00 | host2 |                                            3 |
| 1970-01-01 08:00:10 | host2 |                                            4 |
| 1970-01-01 08:00:05 | host2 |                                            3 |
| 1970-01-01 08:00:05 | host1 |                                            1 |
| 1970-01-01 08:00:00 | host1 |                                            1 |
| 1970-01-01 08:00:10 | host1 |                                            2 |
+---------------------+-------+----------------------------------------------+
```

3. 多个 Range 表达式也可以相互计算，并且 Range 表达式支持分配律，下面两个表达式都是合法且等价的：

```sql
SELECT ts, host, max(cpu) RANGE '10s' - min(cpu) RANGE '10s' FROM host_cpu ALIGN '5s';

SELECT ts, host, (max(cpu) - min(cpu)) RANGE '10s' FROM host_cpu ALIGN '5s';
```

运行后得到

```sql
+---------------------+-------+-------------------------------------------------------------------------------+
| ts                  | host  | MAX(host_cpu.cpu) RANGE 10s FILL NULL - MIN(host_cpu.cpu) RANGE 10s FILL NULL |
+---------------------+-------+-------------------------------------------------------------------------------+
| 1970-01-01 08:00:10 | host1 |                                                                             0 |
| 1970-01-01 08:00:05 | host1 |                                                                           1.1 |
| 1970-01-01 08:00:00 | host1 |                                                                             0 |
| 1970-01-01 08:00:05 | host2 |                                                                           1.1 |
| 1970-01-01 08:00:10 | host2 |                                                                             0 |
| 1970-01-01 08:00:00 | host2 |                                                                             0 |
+---------------------+-------+-------------------------------------------------------------------------------+
```

但注意，Range 表达式修饰的范围是位于 `RANGE` 关键字的前一个表达式，下面的 Range 查询是不合法的，因为 `RANGE` 关键字修饰的是表达式 `2.0`，并不是表达式 `min(cpu * 2.0) * 2.0`

```sql
SELECT ts, host, min(cpu * 2.0) * 2.0 RANGE '10s' FROM host_cpu ALIGN '5s';

ERROR 1815 (HY000): sql parser error: Can't use the RANGE keyword in Expr 2.0 without function
```

可以为表达式加上括号，`RANGE` 关键字会自动应用到括号中包含的所有聚合函数：

```sql
SELECT ts, host, (min(cpu * 2.0) * 2.0) RANGE '10s' FROM host_cpu ALIGN '5s';
```

运行后得到：

```sql
+---------------------+-------+-----------------------------------------------------------------+
| ts                  | host  | MIN(host_cpu.cpu * Float64(2)) RANGE 10s FILL NULL * Float64(2) |
+---------------------+-------+-----------------------------------------------------------------+
| 1970-01-01 08:00:00 | host2 |                                                            13.2 |
| 1970-01-01 08:00:10 | host2 |                                                            17.6 |
| 1970-01-01 08:00:05 | host2 |                                                            13.2 |
| 1970-01-01 08:00:00 | host1 |                                                             4.4 |
| 1970-01-01 08:00:10 | host1 |                                                             8.8 |
| 1970-01-01 08:00:05 | host1 |                                                             4.4 |
+---------------------+-------+-----------------------------------------------------------------+
```

Range 表达式不允许嵌套，嵌套的 Range 查询是不合法的：

```sql
SELECT ts, host, max(min(cpu) RANGE '10s') RANGE '10s' FROM host_cpu ALIGN '5s';

ERROR 1815 (HY000): Range Query: Nest Range Query is not allowed
```

## Range 查询原理

本节介绍 Range 查询的实现原理，以便用户可以更深刻的理解并使用 Range 查询。

Range 查询本质上是一个数据聚合算法，但是与传统 SQL 数据聚合不一样的地方是：在 Range 查询中，一个数据有可能会被聚合到多个 Group 中。比如用户想以天为单位，统计每天的周平均气温，每一个气温点都会在多个周平均气温中被用于计算。上述查询逻辑写成 Range 查询如下所示：

```sql
SELECT avg(temperature) RANGE '7d' from table ALIGN '1d';
```

针对每个 Range 表达式，我们使用 `align_to` （由 `TO` 关键字指定，上文未指定 `TO` 关键字，为 UTC 0 时刻）、`align`（上文为`'1d'`）、`range`（上文为`'7d'`） 三个参数来划分时间窗口（一个时间窗口称为一个 `time slot`），并将数据按照正确的时间戳放入 `time slot` 中。

1. 使用 `align_to`，作为时间轴的时间原点，向前向后以 `align` 为步长，划分出一个个对齐的时间点，这些时间点构成的集合称为 `align_ts` 。 `align_ts = { ts | ts = align_to + k * align, k 为整数 }`
2. 针对 `align_ts` 集合中的每一个元素 `ts`，可以定义一个 `time slot`。 `time slot` 是一个满足 `(ts - range, ts]` 的左开右闭区间。

当 `align > range` 时，划分的 `time slot` 如下图所示，此时一条数据只会属于一个 `time slot`。

![align > range](/range_1.png)

当 `align < range` 时，划分的 `time slot` 如下图所示，此时一条数据可能会属于多个 `time slot`。

![align < range](/range_2.png)
