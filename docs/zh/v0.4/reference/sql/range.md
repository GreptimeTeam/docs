# RANGE QUERY

查询并聚合一个给定长度的时间范围的数据是时序数据常见的一种查询模式，例如 `PromQL` 中的 `Range selector`。而 GreptimeDB 在 SQL 中支持了 Range 查询，用于将时序数据汇总为时间块，并在时间块上进行数据的聚合。Range 查询作为 `SELECT` 语句的一部分，可与 SQL 灵活结合，从而在 SQL 中提供更强大的时序数据查询能力。

## Syntax

一个合法的 Range 查询语法结构如下所示：

```sql
SELECT
  AGGR_FUNCTION(column1, column2,..) RANGE TIME_INTERVAL [FILL FILL_OPTION],
  ...
FROM table_name
ALIGN TIME_INTERVAL [BY (columna, columnb,..)] [FILL FILL_OPTION];
```

- 关键字 `ALIGN`，必选字段，后接参数 `TIME_INTERVAL` ，指明了 Range 查询的步长。
- `TIME_INTERVAL` 遵循 `PromQL` 的 `Time Durations` 类型，访问 [Prometheus 文档](https://prometheus.io/docs/prometheus/latest/querying/basics/#time-durations)
获得更详细的说明。
- 关键字 `BY` ，可选字段，后接参数 `(columna, columnb,..)` ，描述了聚合键。若该字段未给出，默认使用表的主键作为聚合键。
- `AGGR_FUNCTION(column1, column2,..) RANGE TIME_INTERVAL [FILL FILL_OPTION]` 称为一个 Range 表达式。
  - `AGGR_FUNCTION(column1, column2,..)` 是一个聚合函数，代表需要聚合的表达式
  - 关键字 `RANGE`，必选字段，后接参数 `TIME_INTERVAL` 指定了每次数据聚合的时间范围，
  - 关键字 `FILL`，可选字段，后接参数 `FILL_OPTION` 指明了聚合字段为空时的数据填充方法。
  - Range 表达式可与其他运算结合，实现更复杂的查询。具体见[嵌套使用 Range 表达式](#嵌套使用-range-表达式) 。
- 关键字 `FILL`，可以跟在一个 Range 表达式后，作为这个 Range 表达式的数据填充方法；也可以放在 `ALIGN` 后作为缺省数据填充方法。合法的 `FILL_OPTION` 参数见[FILL Option](#fill-option) 。

## 示例

下面这张 `host_cpu` 表，记录了两台机器 `host1` 和 `host2` 在某个时间消耗的 CPU ，以该表为例介绍如何进行 Range 查询。

```sql
+---------------------+-------+------+
| ts                  | host  | cpu  |
+---------------------+-------+------+
| 1970-01-01 08:00:00 | host1 |  1.1 |
| 1970-01-01 08:00:05 | host1 |  2.2 |
| 1970-01-01 08:00:00 | host2 |  3.3 |
| 1970-01-01 08:00:05 | host2 |  4.4 |
+---------------------+-------+------+
```

使用下面的 SQL 语句创建数据表：

```sql
CREATE TABLE host_cpu (
  ts timestamp(3) time index,
  host STRING PRIMARY KEY,
  cpu Float64,
);

INSERT INTO TABLE host_cpu VALUES
    (0,     'host1', 1.1),
    (5000,  'host1', 2.2),
    (0,     'host2', 3.3),
    (5000,  'host2', 4.4);
```

运行这句 Range 查询：

```sql
SELECT 
    ts, 
    host, 
    min(cpu) RANGE '10s',
    max(cpu) RANGE '10s' FILL LINEAR 
FROM host_cpu 
ALIGN '5s' BY (host) FILL PREV;
```

运行后可以得到查询结果：

```sql
+---------------------+-------+---------------------------------------+-----------------------------------------+
| ts                  | host  | MIN(host_cpu.cpu) RANGE 10s FILL PREV | MAX(host_cpu.cpu) RANGE 10s FILL LINEAR |
+---------------------+-------+---------------------------------------+-----------------------------------------+
| 1970-01-01 08:00:00 | host2 |                                   3.3 |                                     3.3 |
| 1970-01-01 08:00:05 | host2 |                                   3.3 |                                     4.4 |
| 1970-01-01 08:00:10 | host2 |                                   4.4 |                                     4.4 |
| 1970-01-01 08:00:00 | host1 |                                   1.1 |                                     1.1 |
| 1970-01-01 08:00:05 | host1 |                                   1.1 |                                     2.2 |
| 1970-01-01 08:00:10 | host1 |                                   2.2 |                                     2.2 |
+---------------------+-------+---------------------------------------+-----------------------------------------+
```


上面这个 RANGE  查询，每隔 5s 统计了一次某台机器在 10s 以内使用 CPU 的最小值和最大值：
1. `ALIGN '5s'` 指明按照  5s 为步长，进行数据的统计，步长对齐到日历。
2. `BY (host)` 指明了聚合键，`BY` 关键字支持省略。如果省略 `BY` 关键字，则默认使用数据表的主键作为聚合键。
3. `max(cpu) RANGE '10s' FILL LINEAR` 是一个 Range 表达式。`RANGE '10s'` 指明了聚合的时间跨度为 10s，`FILL LINEAR` 指明了如果在某个聚合的时间内没有数据的话，使用 `LINEAR` 方式填充。
4. `FILL` 关键字可以跟在 `RANGE` 关键字后面，表示这个 Range 表达式的填充方式，`FILL` 关键字也可以跟在 `BY` 关键字后，作为没有给出 `FILL` 关键字的 Range 表达式的缺省值。`min(cpu) RANGE '10s'` 这个 Range 表达式没有给出 `FILL` ，所以采用缺省的 FILL 填充方式，即 `PREV`。如果缺省的 FILL 也没有给出，则采用 `NULL` 方式填充。


想要使用 Range 查询，该数据表上必须有一列数据在建表时声明为 `time index`，Range 查询使用该列数据作为聚合的时间线依据，如果该数据表没有指定主键，则关键字 `BY` 不能省略。用户也可以使用 `BY` 关键字，声明其他列作为数据聚合的依据。比如下面这个 RANGE 查询，使用 `host` 列的字符串长度 `length(host)` 作为数据聚合的依据。

```sql
SELECT 
    ts, 
    length(host), 
    min(cpu) RANGE '10s' 
FROM host_cpu ALIGN '5s' BY (length(host));
```

运行后可以得到结果：

```sql
+---------------------+---------------------------------+---------------------------------------+
| ts                  | character_length(host_cpu.host) | MIN(host_cpu.cpu) RANGE 10s FILL NULL |
+---------------------+---------------------------------+---------------------------------------+
| 1970-01-01 08:00:00 |                               5 |                                   1.1 |
| 1970-01-01 08:00:05 |                               5 |                                   1.1 |
| 1970-01-01 08:00:10 |                               5 |                                   2.2 |
+---------------------+---------------------------------+---------------------------------------+
```

用户也可以显式通过 `BY ()` 声明**不需要使用聚合键**，将所有数据全部聚合到一个 group 里。**但用户如果直接将 `BY` 关键字省略，则代表着使用数据表的主键来作为数据的聚合键。**

```sql
SELECT 
    ts, 
    min(cpu) RANGE '10s' 
FROM host_cpu ALIGN '5s' BY ();
```

运行后可以得到结果：

```sql
+---------------------+---------------------------------------+
| ts                  | MIN(host_cpu.cpu) RANGE 10s FILL NULL |
+---------------------+---------------------------------------+
| 1970-01-01 08:00:05 |                                   1.1 |
| 1970-01-01 08:00:00 |                                   1.1 |
| 1970-01-01 08:00:10 |                                   2.2 |
+---------------------+---------------------------------------+
```

## FILL OPTION

FILL 有以下几种填充方式：

|   FILL   |                                                      描述                                                      |
| :------: | :------------------------------------------------------------------------------------------------------------: |
|  `NULL`  |                                              直接使用 `NULL` 填充                                              |
|  `PREV`  |                                             使用前一个点的数据填充                                             |
| `LINEAR` | 用前后两点的数据取平均，如果一个整数类型使用 `LINEAR` 填充，则该列的变量类型会在计算的时候被隐式转换为浮点类型 |
|   `X`    |                        填充一个常量，该常量的数据类型必须和 Range 表达式的变量类型一致                         |


以下面这张表为例

```sql
+---------------------+-------+------+
| ts                  | host  | cpu  |
+---------------------+-------+------+
| 1970-01-01 08:00:00 | host1 |  4.5 |
| 1970-01-01 08:00:05 | host1 | NULL |
| 1970-01-01 08:00:10 | host1 |  6.5 |
+---------------------+-------+------+
```

使用 `NULL` 进行 FILL

```sql
SELECT ts, min(cpu) RANGE '5s' FILL NULL FROM host_cpu ALIGN '5s';
```

运行后得到结果：

```sql
+---------------------+--------------------------------------+
| ts                  | MIN(host_cpu.cpu) RANGE 5s FILL NULL |
+---------------------+--------------------------------------+
| 1970-01-01 08:00:00 |                                  4.5 |
| 1970-01-01 08:00:05 |                                 NULL |
| 1970-01-01 08:00:10 |                                  6.5 |
+---------------------+--------------------------------------+
```

使用 `PREV` 进行 FILL

```sql
SELECT ts, min(cpu) RANGE '5s' FILL PREV FROM host_cpu ALIGN '5s';
```

运行后得到结果：

```sql
+---------------------+--------------------------------------+
| ts                  | MIN(host_cpu.cpu) RANGE 5s FILL PREV |
+---------------------+--------------------------------------+
| 1970-01-01 08:00:00 |                                  4.5 |
| 1970-01-01 08:00:05 |                                  4.5 |
| 1970-01-01 08:00:10 |                                  6.5 |
+---------------------+--------------------------------------+
```

使用 `LINEAR` 进行 FILL

```sql
SELECT ts, min(cpu) RANGE '5s' FILL LINEAR FROM host_cpu ALIGN '5s';
```

运行后得到结果：

```sql
+---------------------+----------------------------------------+
| ts                  | MIN(host_cpu.cpu) RANGE 5s FILL LINEAR |
+---------------------+----------------------------------------+
| 1970-01-01 08:00:00 |                                    4.5 |
| 1970-01-01 08:00:05 |                                    5.5 |
| 1970-01-01 08:00:10 |                                    6.5 |
+---------------------+----------------------------------------+
```

使用常量值 `6.0` 进行 FILL

```sql
SELECT ts, min(cpu) RANGE '5s' FILL 6.0 FROM host_cpu ALIGN '5s';
```

运行后得到结果：

```sql
+---------------------+-----------------------------------+
| ts                  | MIN(host_cpu.cpu) RANGE 5s FILL 6 |
+---------------------+-----------------------------------+
| 1970-01-01 08:00:00 |                               4.5 |
| 1970-01-01 08:00:05 |                                 6 |
| 1970-01-01 08:00:10 |                               6.5 |
+---------------------+-----------------------------------+
```

## 嵌套使用 Range 表达式

Range 表达式支持灵活的嵌套，可以将 Range 表达式结合各种运算，提供更强大的查询能力。

以下面这张表为例：

```sql
+---------------------+-------+------+
| ts                  | host  | cpu  |
+---------------------+-------+------+
| 1970-01-01 08:00:00 | host1 |  1.1 |
| 1970-01-01 08:00:05 | host1 |  2.2 |
| 1970-01-01 08:00:00 | host2 |  3.3 |
| 1970-01-01 08:00:05 | host2 |  4.4 |
+---------------------+-------+------+
```

1. 聚合函数内部和外部都支持计算：

```sql
SELECT ts, host, 2.0 * min(cpu * 2.0) RANGE '10s' FROM host_cpu ALIGN '5s';
```

运行后得到

```sql
+---------------------+-------+-----------------------------------------------------------------+
| ts                  | host  | Float64(2) * MIN(host_cpu.cpu * Float64(2)) RANGE 10s FILL NULL |
+---------------------+-------+-----------------------------------------------------------------+
| 1970-01-01 08:00:00 | host2 |                                                            13.2 |
| 1970-01-01 08:00:10 | host2 |                                                            17.6 |
| 1970-01-01 08:00:05 | host2 |                                                            13.2 |
| 1970-01-01 08:00:10 | host1 |                                                             8.8 |
| 1970-01-01 08:00:05 | host1 |                                                             4.4 |
| 1970-01-01 08:00:00 | host1 |                                                             4.4 |
+---------------------+-------+-----------------------------------------------------------------+
```


2. 聚合函数内部和外部都支持使用 Scalar 函数：
   - `min(round(cpu)) RANGE '10s'` 表示对每个值先使用 `round` 函数四舍五入后再进行聚合
   - `round(min(cpu) RANGE '10s')` 表示对每个聚合完成的结果使用 `round` 函数四舍五入

```sql
SELECT ts, host, min(round(cpu)) RANGE '10s' FROM host_cpu ALIGN '5s';
```
运行后得到

```sql
+---------------------+-------+----------------------------------------------+
| ts                  | host  | MIN(round(host_cpu.cpu)) RANGE 10s FILL NULL |
+---------------------+-------+----------------------------------------------+
| 1970-01-01 08:00:05 | host1 |                                            1 |
| 1970-01-01 08:00:00 | host1 |                                            1 |
| 1970-01-01 08:00:10 | host1 |                                            2 |
| 1970-01-01 08:00:00 | host2 |                                            3 |
| 1970-01-01 08:00:10 | host2 |                                            4 |
| 1970-01-01 08:00:05 | host2 |                                            3 |
+---------------------+-------+----------------------------------------------+
```


```sql
SELECT ts, host, round(min(cpu) RANGE '10s') FROM host_cpu ALIGN '5s';
```

运行后得到

```sql
+---------------------+-------+----------------------------------------------+
| ts                  | host  | round(MIN(host_cpu.cpu) RANGE 10s FILL NULL) |
+---------------------+-------+----------------------------------------------+
| 1970-01-01 08:00:00 | host2 |                                            3 |
| 1970-01-01 08:00:10 | host2 |                                            4 |
| 1970-01-01 08:00:05 | host2 |                                            3 |
| 1970-01-01 08:00:05 | host1 |                                            1 |
| 1970-01-01 08:00:00 | host1 |                                            1 |
| 1970-01-01 08:00:10 | host1 |                                            2 |
+---------------------+-------+----------------------------------------------+
```

3. 多个 Range 表达式也可以相互计算，并且 Range 表达式支持分配律，下面两个表达式都是合法且等价的：

```sql
SELECT ts, host, max(cpu) RANGE '10s' - min(cpu) RANGE '10s' FROM host_cpu ALIGN '5s';

SELECT ts, host, (max(cpu) - min(cpu)) RANGE '10s' FROM host_cpu ALIGN '5s';
```

运行后得到

```sql
+---------------------+-------+-------------------------------------------------------------------------------+
| ts                  | host  | MAX(host_cpu.cpu) RANGE 10s FILL NULL - MIN(host_cpu.cpu) RANGE 10s FILL NULL |
+---------------------+-------+-------------------------------------------------------------------------------+
| 1970-01-01 08:00:10 | host1 |                                                                             0 |
| 1970-01-01 08:00:05 | host1 |                                                                           1.1 |
| 1970-01-01 08:00:00 | host1 |                                                                             0 |
| 1970-01-01 08:00:05 | host2 |                                                                           1.1 |
| 1970-01-01 08:00:10 | host2 |                                                                             0 |
| 1970-01-01 08:00:00 | host2 |                                                                             0 |
+---------------------+-------+-------------------------------------------------------------------------------+
```

但注意，Range 表达式修饰的范围是位于 `RANGE` 关键字的前一个表达式，下面的 Range 查询是不合法的，因为 `RANGE` 关键字修饰的是表达式 `2.0`，并不是表达式 `min(cpu * 2.0) * 2.0`

```sql
SELECT ts, host, min(cpu * 2.0) * 2.0 RANGE '10s' FROM host_cpu ALIGN '5s';

ERROR 1815 (HY000): sql parser error: Can't use the RANGE keyword in Expr 2.0 without function
```

可以为表达式加上括号，`RANGE` 关键字会自动应用到括号中包含的所有聚合函数：

```sql
SELECT ts, host, (min(cpu * 2.0) * 2.0) RANGE '10s' FROM host_cpu ALIGN '5s';
```

运行后得到：

```sql
+---------------------+-------+-----------------------------------------------------------------+
| ts                  | host  | MIN(host_cpu.cpu * Float64(2)) RANGE 10s FILL NULL * Float64(2) |
+---------------------+-------+-----------------------------------------------------------------+
| 1970-01-01 08:00:00 | host2 |                                                            13.2 |
| 1970-01-01 08:00:10 | host2 |                                                            17.6 |
| 1970-01-01 08:00:05 | host2 |                                                            13.2 |
| 1970-01-01 08:00:00 | host1 |                                                             4.4 |
| 1970-01-01 08:00:10 | host1 |                                                             8.8 |
| 1970-01-01 08:00:05 | host1 |                                                             4.4 |
+---------------------+-------+-----------------------------------------------------------------+
```

Range 表达式不允许嵌套，嵌套的 Range 查询是不合法的：

```sql
SELECT ts, host, max(min(cpu) RANGE '10s') RANGE '10s' FROM host_cpu ALIGN '5s';

ERROR 1815 (HY000): Range Query: Nest Range Query is not allowed
```